"""
Author              : Tamer ÅžENER
Institution         : Istanbul Technical University
Contact             : tamsener@gmail.com
Created             : May 3rd 2020

This code reads output files of OpenFOAM and calculates energy density spectrum and plots the output values.
"""
import numpy as np
import scipy as sc
from scipy import signal
import matplotlib.pyplot as plt
from numpy.fft import fftn
import sys
import os


class VelocityField(object):
    #  This class provides methods to be used in this script. The general functions are written here.
    @staticmethod
    def read_velocity_field(VelField, time, U_x, U_y, U_z):
        """
        This method reads given file and seperates the time array from velocities on each probe. Also, on each probe the
        data is written for, X, Y, and Z direction and those should be seperated. This method separates velocities on
        each direction for each probe and reading from the file results in 4 different arrays, one is time array, other
        is velocities in X direction, the other 2 are velocities in Y and Z direction. On these arrays, each row repre-
        sents time step and each column stands for probe number. For example, for velocity on Y direction, Y(25, 4)
        represents data on 25th timestep on probe number 4.

        :param VelField: Read values from a directory. This is the data generated by OpenFOAM with probes field. This
                       method organizes the fields itself. This parameter is directly the one that is read from the
                       OpenFOAM value itself.
        :param time:   Empty time array that was created on the object that uses this method. Its length depends on the
                       timestep lengt.
        :param U_x:    Empty x velocity array that was created on the object that uses this method. Its length depends
                       on the timestep lengt.
        :param U_y:    Empty y velocity array that was created on the object that uses this method. Its length depends
                       on the timestep lengt.
        :param U_z:    Empty z velocity array that was created on the object that uses this method. Its length depends
                       on the timestep lengt.
        :return:       Separated values for time and velocities.
        """
        for i in range(len(VelField)):
            time[i] = float(VelField[i].split()[0])
            probe_counter = 0
            for j in range(len(VelField[i].split())):
                if j == 0:
                    continue
                else:
                    #  Pharantesis are unnecassery, to get rid of them split read data
                    split_for_pharantesis = list(VelField[i].split()[j])
                    if len(split_for_pharantesis) > 1 and split_for_pharantesis[0] == '(':
                        U_x[i, probe_counter] = float(VelField[i].split()[j][1:])
                    elif len(split_for_pharantesis) > 1 and split_for_pharantesis[-1] == ')':
                        U_z[i, probe_counter] = float(VelField[i].split()[j][0:-1])
                    else:
                        U_y[i, probe_counter] = float(VelField[i].split()[j])

                    if np.mod(j, 3) == 0:
                        probe_counter += 1
        return time, U_x, U_y, U_z

    @staticmethod
    def probe_number(U_file_path):
        """
        This method reads the probe numbers on given file path. This file is velocity data file that is generated by
        OpenFOAM.
        :param U_file_path: The path of the velocity data file, that is generated by OpenFOAM probe field
        :return: probe numbers, the coulumn number in the file and the the raw data line that the code shoulds stars
                 from. The reading_start_line is necessary since the file has several lines that gives information about
                 probe locations and headers.
        """
        #  Open files
        UMean = open(U_file_path, "r")
        #  Read file to obtain probe number
        ProbeNo = UMean.readlines()

        for i in range(len(ProbeNo)):
            if ProbeNo[i + 1].split()[1] == 'Time':
                no_of_probes = int(ProbeNo[i].split()[-1])  # The last element is the probe number
                break

        no_of_probes += 1  # The first probe number is 0. This addition is necessary to count the last probe
        column_count = no_of_probes + 1  # in addition to probe data, there is time column in each line
        reading_start_line = no_of_probes + 2  # add next 2 lines to get rid of title lines

        return no_of_probes, column_count, reading_start_line


class UMeanField(object):
    """
    This class reads and attends the mean velocity field in each direction. This class uses the static methods to
    read velocity field into mean velocity arrays. Therefore, the velocity_field_path should be correct and it should
    be the path of the mean velocity data file. No other
    """

    def __init__(self, no_of_probes, reading_start_line, velocity_field_path):
        self.UMean = open(velocity_field_path, "r")
        self.Umean_values = self.UMean.readlines()[reading_start_line:]
        self.time = len(self.Umean_values) * [0]  # create time list to get the time series data
        self.UMean_x = np.zeros(shape=(len(self.Umean_values), no_of_probes))  # create x_mean
        self.UMean_y = np.zeros(shape=(len(self.Umean_values), no_of_probes))  # create y_mean
        self.UMean_z = np.zeros(shape=(len(self.Umean_values), no_of_probes))  # create z_mean

    def UMean_field_in_arrays(self):
        self.time, self.UMean_x, self.UMean_y, self.UMean_z = VelocityField.read_velocity_field(self.Umean_values,
        self.time, self.UMean_x, self.UMean_y, self.UMean_z)


class UField(object):

    def __init__(self, no_of_probes, reading_start_line, velocity_field_path):
        self.U = open(velocity_field_path, "r")
        self.U = self.U.readlines()[reading_start_line:]
        self.time = len(self.U) * [0]  # create time list to get the time series data
        self.U_x = np.zeros(shape=(len(self.U), no_of_probes))  # create x_mean
        self.U_y = np.zeros(shape=(len(self.U), no_of_probes))  # create y_mean
        self.U_z = np.zeros(shape=(len(self.U), no_of_probes))  # create z_mean

    def U_field_in_arrays(self):
        self.time, self.U_x, self.U_y, self.U_z = VelocityField.read_velocity_field(self.U,
        self.time, self.U_x, self.U_y, self.U_z)


class UPrimeField(object):
    """
    Class calculates the fluctuating velocity with the difference of velocity field and mean velocity field.
        U = UMean + UPrime
    """
    def __init__(self, no_of_probes, UMean, U):
        self.time = UMean.time  # Take time directly from previous calculations
        self.UmeanField_x = UMean.UMean_x
        self.UmeanField_y = UMean.UMean_y
        self.UmeanField_z = UMean.UMean_z
        self.UField_x = U.U_x
        self.UField_y = U.U_y
        self.UField_z = U.U_z
        #  Calculate the prime velocity field
        self.UPrime_x = self.UField_x - self.UmeanField_x
        self.UPrime_y = self.UField_y - self.UmeanField_y
        self.UPrime_z = self.UField_z - self.UmeanField_z

class TKE_calculation(object):
    """
    Calculate the TKE from the fluctuating velocity field (UPrime). The equation used is Pope 2000 book eq. 6.103
    """
    def __init__(self, UPrime):
        self.Uprime_x = UPrime.UPrime_x
        self.Uprime_y = UPrime.UPrime_y
        self.Uprime_z = UPrime.UPrime_z
        nx = len(self.Uprime_x)
        ny = len(self.Uprime_y)
        nz = len(self.Uprime_z)
        self.TKE = np.zeros(shape=(nx, ny, nz))
        #  Transform prime values to frequency domanin
        self.Ux_fft = fftn(self.Uprime_x)/(nx*ny*nz)
        self.Uy_fft = fftn(self.Uprime_y)/(nx*ny*nz)
        self.Uz_fft = fftn(self.Uprime_z)/(nx*ny*nz)

    def calculate_tke(self, probe):
        self.TKE = 0.5 * (self.Ux_fft[:, probe] * np.conj(self.Ux_fft[:, probe]) +
                          self.Uy_fft[:, probe] * np.conj(self.Uy_fft[:, probe]) +
                          self.Uz_fft[:, probe] * np.conj(self.Uz_fft[:, probe])).real


#  Paths of the used files
code_path = os.path.dirname(sys.argv[0])
velocity_fields_path = code_path + '/VelocityField'
U_file_path = velocity_fields_path + '/U.txt'
UMean_file_path = velocity_fields_path + '/UMean'

#  Read probe numbers
no_of_probes, column_count, reading_start_line = VelocityField.probe_number(UMean_file_path)

#  Read mean velocity field
Mean_vel = UMeanField(no_of_probes, reading_start_line, UMean_file_path)
Mean_vel.UMean_field_in_arrays()
#  Read total velocity field
Total_vel = UField(no_of_probes, reading_start_line, U_file_path)
Total_vel.U_field_in_arrays()
#  Calculate fluctuating velocity field
UPrime = UPrimeField(no_of_probes, Mean_vel, Total_vel)


#  Calculate TKE
probe = 6  # The probe ID, i.e identicator on which probe the calculations will be made
TKE = TKE_calculation(UPrime)
TKE.calculate_tke(probe)
print(type(TKE.TKE))

# Energy density spectrum calculation and ploting
frequency, time, Energy = signal.spectrogram(TKE.TKE, 1)
plt.semilogy(frequency, Energy)
plt.title('Energy Spectrum')
plt.xlabel('frequency [Hz]')
plt.ylabel('E(f)')
plt.show()





